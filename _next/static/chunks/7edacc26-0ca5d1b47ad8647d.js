"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[626],{10400:function(t,e,i){var s=this&&this.__awaiter||function(t,e,i,s){return new(i||(i=Promise))(function(a,r){function o(t){try{l(s.next(t))}catch(t){r(t)}}function d(t){try{l(s.throw(t))}catch(t){r(t)}}function l(t){var e;t.done?a(t.value):((e=t.value)instanceof i?e:new i(function(t){t(e)})).then(o,d)}l((s=s.apply(t,e||[])).next())})},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.PlatformVMAPI=void 0;let r=i(13055),o=a(i(13550)),d=i(98769),l=a(i(89734)),n=i(8201),h=i(89858),u=i(78034),c=i(11713),f=i(77673),g=i(3421),A=i(74906),m=i(77556),D=i(37883),k=i(3079),b=l.default.getInstance(),T=k.Serialization.getInstance();class y extends d.JRPCAPI{constructor(t,e="/ext/bc/P"){super(t,e),this.keychain=new n.KeyChain("",""),this.blockchainID=h.PlatformChainID,this.blockchainAlias=void 0,this.AVAXAssetID=void 0,this.txFee=void 0,this.creationTxFee=void 0,this.minValidatorStake=void 0,this.minDelegatorStake=void 0,this.getBlockchainAlias=()=>{if(void 0===this.blockchainAlias){let t=this.core.getNetworkID();if(!(t in h.Defaults.network)||!(this.blockchainID in h.Defaults.network[`${t}`]))return;this.blockchainAlias=h.Defaults.network[`${t}`][this.blockchainID].alias}return this.blockchainAlias},this.setBlockchainAlias=t=>{this.blockchainAlias=t},this.getBlockchainID=()=>this.blockchainID,this.refreshBlockchainID=t=>{let e=this.core.getNetworkID();return void 0===t&&void 0!==h.Defaults.network[`${e}`]?(this.blockchainID=h.PlatformChainID,!0):"string"==typeof t&&(this.blockchainID=t,!0)},this.parseAddress=t=>{let e=this.getBlockchainAlias(),i=this.getBlockchainID();return b.parseAddress(t,i,e,u.PlatformVMConstants.ADDRESSLENGTH)},this.addressFromBuffer=t=>{let e=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID();return T.bufferToType(t,"bech32",this.core.getHRP(),e)},this.getAVAXAssetID=(t=!1)=>s(this,void 0,void 0,function*(){if(void 0===this.AVAXAssetID||t){let t=yield this.getStakingAssetID();this.AVAXAssetID=b.cb58Decode(t)}return this.AVAXAssetID}),this.setAVAXAssetID=t=>{"string"==typeof t&&(t=b.cb58Decode(t)),this.AVAXAssetID=t},this.getDefaultTxFee=()=>new o.default(this.core.getNetworkID() in h.Defaults.network?h.Defaults.network[this.core.getNetworkID()].P.txFee:0),this.getTxFee=()=>(void 0===this.txFee&&(this.txFee=this.getDefaultTxFee()),this.txFee),this.getCreateSubnetTxFee=()=>new o.default(this.core.getNetworkID() in h.Defaults.network?h.Defaults.network[this.core.getNetworkID()].P.createSubnetTx:0),this.getCreateChainTxFee=()=>new o.default(this.core.getNetworkID() in h.Defaults.network?h.Defaults.network[this.core.getNetworkID()].P.createChainTx:0),this.setTxFee=t=>{this.txFee=t},this.getDefaultCreationTxFee=()=>new o.default(this.core.getNetworkID() in h.Defaults.network?h.Defaults.network[this.core.getNetworkID()].P.creationTxFee:0),this.getCreationTxFee=()=>(void 0===this.creationTxFee&&(this.creationTxFee=this.getDefaultCreationTxFee()),this.creationTxFee),this.setCreationTxFee=t=>{this.creationTxFee=t},this.keyChain=()=>this.keychain,this.newKeyChain=()=>{let t=this.getBlockchainAlias();return t?this.keychain=new n.KeyChain(this.core.getHRP(),t):this.keychain=new n.KeyChain(this.core.getHRP(),this.blockchainID),this.keychain},this.checkGooseEgg=(t,e=new o.default(0))=>s(this,void 0,void 0,function*(){let i=yield this.getAVAXAssetID(),s=e.gt(new o.default(0))?e:t.getOutputTotal(i),a=t.getBurn(i);return!!(a.lte(h.ONEAVAX.mul(new o.default(10)))||a.lte(s))}),this.getStakingAssetID=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getStakingAssetID");return t.data.result.assetID}),this.createBlockchain=(t,e,i,a,r,o,d)=>s(this,void 0,void 0,function*(){let s={username:t,password:e,fxIDs:r,vmID:a,name:o,genesisData:d};"string"==typeof i?s.subnetID=i:void 0!==i&&(s.subnetID=b.cb58Encode(i));let l=yield this.callMethod("platform.createBlockchain",s);return l.data.result.txID}),this.getBlockchainStatus=t=>s(this,void 0,void 0,function*(){let e=yield this.callMethod("platform.getBlockchainStatus",{blockchainID:t});return e.data.result.status}),this.getValidatorsAt=(t,e)=>s(this,void 0,void 0,function*(){let i={height:t};void 0!==e&&(i.subnetID=e);let s=yield this.callMethod("platform.getValidatorsAt",i);return s.data.result}),this.createAddress=(t,e)=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.createAddress",{username:t,password:e});return i.data.result.address}),this.getBalance=t=>s(this,void 0,void 0,function*(){if(void 0===this.parseAddress(t))throw new m.AddressError("Error - PlatformVMAPI.getBalance: Invalid address format");let e=yield this.callMethod("platform.getBalance",{address:t});return e.data.result}),this.listAddresses=(t,e)=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.listAddresses",{username:t,password:e});return i.data.result.addresses}),this.getCurrentValidators=(t,e)=>s(this,void 0,void 0,function*(){let i={};"string"==typeof t?i.subnetID=t:void 0!==t&&(i.subnetID=b.cb58Encode(t)),void 0!==e&&e.length>0&&(i.nodeIDs=e);let s=yield this.callMethod("platform.getCurrentValidators",i);return s.data.result}),this.getPendingValidators=(t,e)=>s(this,void 0,void 0,function*(){let i={};"string"==typeof t?i.subnetID=t:void 0!==t&&(i.subnetID=b.cb58Encode(t)),void 0!==e&&e.length>0&&(i.nodeIDs=e);let s=yield this.callMethod("platform.getPendingValidators",i);return s.data.result}),this.sampleValidators=(t,e)=>s(this,void 0,void 0,function*(){let i={size:t.toString()};"string"==typeof e?i.subnetID=e:void 0!==e&&(i.subnetID=b.cb58Encode(e));let s=yield this.callMethod("platform.sampleValidators",i);return s.data.result.validators}),this.addValidator=(t,e,i,a,r,o,d,l)=>s(this,void 0,void 0,function*(){let s={username:t,password:e,nodeID:i,startTime:a.getTime()/1e3,endTime:r.getTime()/1e3,stakeAmount:o.toString(10),rewardAddress:d};void 0!==l&&(s.delegationFeeRate=l.toString(10));let n=yield this.callMethod("platform.addValidator",s);return n.data.result.txID}),this.addSubnetValidator=(t,e,i,a,r,o,d)=>s(this,void 0,void 0,function*(){let s={username:t,password:e,nodeID:i,startTime:r.getTime()/1e3,endTime:o.getTime()/1e3,weight:d};"string"==typeof a?s.subnetID=a:void 0!==a&&(s.subnetID=b.cb58Encode(a));let l=yield this.callMethod("platform.addSubnetValidator",s);return l.data.result.txID}),this.addDelegator=(t,e,i,a,r,o,d)=>s(this,void 0,void 0,function*(){let s={username:t,password:e,nodeID:i,startTime:a.getTime()/1e3,endTime:r.getTime()/1e3,stakeAmount:o.toString(10),rewardAddress:d},l=yield this.callMethod("platform.addDelegator",s);return l.data.result.txID}),this.createSubnet=(t,e,i,a)=>s(this,void 0,void 0,function*(){let s=yield this.callMethod("platform.createSubnet",{username:t,password:e,controlKeys:i,threshold:a});return s.data.result.txID?s.data.result.txID:s.data.result}),this.validatedBy=t=>s(this,void 0,void 0,function*(){let e=yield this.callMethod("platform.validatedBy",{blockchainID:t});return e.data.result.subnetID}),this.validates=t=>s(this,void 0,void 0,function*(){let e={subnetID:t};"string"==typeof t?e.subnetID=t:void 0!==t&&(e.subnetID=b.cb58Encode(t));let i=yield this.callMethod("platform.validates",e);return i.data.result.blockchainIDs}),this.getBlockchains=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getBlockchains");return t.data.result.blockchains}),this.exportAVAX=(t,e,i,a)=>s(this,void 0,void 0,function*(){let s={username:t,password:e,to:a,amount:i.toString(10)},r=yield this.callMethod("platform.exportAVAX",s);return r.data.result.txID?r.data.result.txID:r.data.result}),this.importAVAX=(t,e,i,a)=>s(this,void 0,void 0,function*(){let s=yield this.callMethod("platform.importAVAX",{to:i,sourceChain:a,username:t,password:e});return s.data.result.txID?s.data.result.txID:s.data.result}),this.issueTx=t=>s(this,void 0,void 0,function*(){let e="";if("string"==typeof t)e=t;else if(t instanceof r.Buffer){let i=new c.Tx;i.fromBuffer(t),e=i.toStringHex()}else if(t instanceof c.Tx)e=t.toStringHex();else throw new m.TransactionError("Error - platform.issueTx: provided tx is not expected type of string, Buffer, or Tx");let i={tx:e.toString(),encoding:"hex"},s=yield this.callMethod("platform.issueTx",i);return s.data.result.txID}),this.getCurrentSupply=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getCurrentSupply");return new o.default(t.data.result.supply,10)}),this.getHeight=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getHeight");return new o.default(t.data.result.height,10)}),this.getMinStake=(t=!1)=>s(this,void 0,void 0,function*(){if(!0!==t&&void 0!==this.minValidatorStake&&void 0!==this.minDelegatorStake)return{minValidatorStake:this.minValidatorStake,minDelegatorStake:this.minDelegatorStake};let e=yield this.callMethod("platform.getMinStake");return this.minValidatorStake=new o.default(e.data.result.minValidatorStake,10),this.minDelegatorStake=new o.default(e.data.result.minDelegatorStake,10),{minValidatorStake:this.minValidatorStake,minDelegatorStake:this.minDelegatorStake}}),this.getTotalStake=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getTotalStake");return new o.default(t.data.result.stake,10)}),this.getMaxStakeAmount=(t,e,i,a)=>s(this,void 0,void 0,function*(){let s=(0,g.UnixNow)();if(i.gt(s)||a.lte(i))throw new m.TimeError("PlatformVMAPI.getMaxStakeAmount -- startTime must be in the past and endTime must come after startTime");let r={nodeID:e,startTime:i,endTime:a};"string"==typeof t?r.subnetID=t:void 0!==t&&(r.subnetID=b.cb58Encode(t));let d=yield this.callMethod("platform.getMaxStakeAmount",r);return new o.default(d.data.result.amount,10)}),this.setMinStake=(t,e)=>{void 0!==t&&(this.minValidatorStake=t),void 0!==e&&(this.minDelegatorStake=e)},this.getStake=(t,e="hex")=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.getStake",{addresses:t,encoding:e});return{staked:new o.default(i.data.result.staked,10),stakedOutputs:i.data.result.stakedOutputs.map(t=>{let i;let s=new D.TransferableOutput;return i="cb58"===e?b.cb58Decode(t):r.Buffer.from(t.replace(/0x/g,""),"hex"),s.fromBuffer(i,2),s})}}),this.getSubnets=t=>s(this,void 0,void 0,function*(){let e={};e.ids=t;let i=yield this.callMethod("platform.getSubnets",e);return i.data.result.subnets}),this.exportKey=(t,e,i)=>s(this,void 0,void 0,function*(){let s=yield this.callMethod("platform.exportKey",{username:t,password:e,address:i});return s.data.result.privateKey?s.data.result.privateKey:s.data.result}),this.importKey=(t,e,i)=>s(this,void 0,void 0,function*(){let s=yield this.callMethod("platform.importKey",{username:t,password:e,privateKey:i});return s.data.result.address?s.data.result.address:s.data.result}),this.getTx=(t,e="hex")=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.getTx",{txID:t,encoding:e});return i.data.result.tx?i.data.result.tx:i.data.result}),this.getTxStatus=(t,e=!0)=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.getTxStatus",{txID:t,includeReason:e});return i.data.result}),this.getUTXOs=(t,e,i=0,a,o,d="hex")=>s(this,void 0,void 0,function*(){"string"==typeof t&&(t=[t]);let s={addresses:t,limit:i,encoding:d};void 0!==a&&a&&(s.startIndex=a),void 0!==e&&(s.sourceChain=e);let l=yield this.callMethod("platform.getUTXOs",s),n=new A.UTXOSet,h=l.data.result.utxos;if(o&&"object"==typeof o){if(this.db.has(o.getName())){let t=this.db.get(o.getName());if(Array.isArray(t)){n.addArray(h);let e=new A.UTXOSet;e.addArray(t),e.mergeByRule(n,o.getMergeRule()),h=e.getAllUTXOStrings()}}this.db.set(o.getName(),h,o.getOverwrite())}if(h.length>0&&"0x"===h[0].substring(0,2)){let t=[];h.forEach(e=>{t.push(b.cb58Encode(new r.Buffer(e.slice(2),"hex")))}),n.addArray(t,!1)}else n.addArray(h,!1);return l.data.result.utxos=n,l.data.result.numFetched=parseInt(l.data.result.numFetched),l.data.result}),this.buildImportTx=(t,e,i,a,d,l,n,h=(0,g.UnixNow)(),u=new o.default(0),c=1)=>s(this,void 0,void 0,function*(){let s;let o=this._cleanAddressArray(a,"buildImportTx").map(t=>b.stringToAddress(t)),g=this._cleanAddressArray(d,"buildImportTx").map(t=>b.stringToAddress(t)),A=this._cleanAddressArray(l,"buildImportTx").map(t=>b.stringToAddress(t));if(void 0===i)throw new m.ChainIdError("Error - PlatformVMAPI.buildImportTx: Source ChainID is undefined.");if("string"==typeof i)s=i,i=b.cb58Decode(i);else if(!(i instanceof r.Buffer))throw new m.ChainIdError("Error - PlatformVMAPI.buildImportTx: Invalid destinationChain type: "+typeof i);let D=yield(yield this.getUTXOs(e,s,0,void 0)).utxos,k=yield this.getAVAXAssetID();n instanceof f.PayloadBase&&(n=n.getPayload());let T=D.getAllUTXOs(),y=t.buildImportTx(this.core.getNetworkID(),b.cb58Decode(this.blockchainID),o,g,A,T,i,this.getTxFee(),k,n,h,u,c);if(!(yield this.checkGooseEgg(y)))throw new m.GooseEggCheckError("Failed Goose Egg Check");return y}),this.buildExportTx=(t,e,i,a,d,l,n,h=(0,g.UnixNow)(),u=new o.default(0),c=1)=>s(this,void 0,void 0,function*(){let s={};if(a.map(t=>{s[t.split("-")[0]]=!0}),1!==Object.keys(s).length)throw new m.AddressError("Error - PlatformVMAPI.buildExportTx: To addresses must have the same chainID prefix.");if(void 0===i)throw new m.ChainIdError("Error - PlatformVMAPI.buildExportTx: Destination ChainID is undefined.");if("string"==typeof i)i=b.cb58Decode(i);else if(!(i instanceof r.Buffer))throw new m.ChainIdError("Error - PlatformVMAPI.buildExportTx: Invalid destinationChain type: "+typeof i);if(32!==i.length)throw new m.ChainIdError("Error - PlatformVMAPI.buildExportTx: Destination ChainID must be 32 bytes in length.");let o=[];a.map(t=>{o.push(b.stringToAddress(t))});let g=this._cleanAddressArray(d,"buildExportTx").map(t=>b.stringToAddress(t)),A=this._cleanAddressArray(l,"buildExportTx").map(t=>b.stringToAddress(t));n instanceof f.PayloadBase&&(n=n.getPayload());let D=yield this.getAVAXAssetID(),k=t.buildExportTx(this.core.getNetworkID(),b.cb58Decode(this.blockchainID),e,D,o,g,A,i,this.getTxFee(),D,n,h,u,c);if(!(yield this.checkGooseEgg(k)))throw new m.GooseEggCheckError("Failed Goose Egg Check");return k}),this.buildAddSubnetValidatorTx=(t,e,i,a,r,o,d,l,n,h=(0,g.UnixNow)(),u=[])=>s(this,void 0,void 0,function*(){let s=this._cleanAddressArray(e,"buildAddSubnetValidatorTx").map(t=>b.stringToAddress(t)),c=this._cleanAddressArray(i,"buildAddSubnetValidatorTx").map(t=>b.stringToAddress(t));n instanceof f.PayloadBase&&(n=n.getPayload());let A=yield this.getAVAXAssetID(),m=(0,g.UnixNow)();if(r.lt(m)||o.lte(r))throw Error("PlatformVMAPI.buildAddSubnetValidatorTx -- startTime must be in the future and endTime must come after startTime");let D=t.buildAddSubnetValidatorTx(this.core.getNetworkID(),b.cb58Decode(this.blockchainID),s,c,(0,g.NodeIDStringToBuffer)(a),r,o,d,l,this.getDefaultTxFee(),A,n,h,u);if(!(yield this.checkGooseEgg(D)))throw Error("Failed Goose Egg Check");return D}),this.buildAddDelegatorTx=(t,e,i,a,r,d,l,n,h,u=new o.default(0),c=1,A,D=(0,g.UnixNow)())=>s(this,void 0,void 0,function*(){let s=this._cleanAddressArray(e,"buildAddDelegatorTx").map(t=>b.stringToAddress(t)),k=this._cleanAddressArray(i,"buildAddDelegatorTx").map(t=>b.stringToAddress(t)),T=this._cleanAddressArray(a,"buildAddDelegatorTx").map(t=>b.stringToAddress(t)),y=this._cleanAddressArray(h,"buildAddDelegatorTx").map(t=>b.stringToAddress(t));A instanceof f.PayloadBase&&(A=A.getPayload());let x=(yield this.getMinStake()).minDelegatorStake;if(n.lt(x))throw new m.StakeError("PlatformVMAPI.buildAddDelegatorTx -- stake amount must be at least "+x.toString(10));let p=yield this.getAVAXAssetID(),v=(0,g.UnixNow)();if(d.lt(v)||l.lte(d))throw new m.TimeError("PlatformVMAPI.buildAddDelegatorTx -- startTime must be in the future and endTime must come after startTime");let I=t.buildAddDelegatorTx(this.core.getNetworkID(),b.cb58Decode(this.blockchainID),p,s,k,T,(0,g.NodeIDStringToBuffer)(r),d,l,n,u,c,y,new o.default(0),p,A,D);if(!(yield this.checkGooseEgg(I)))throw new m.GooseEggCheckError("Failed Goose Egg Check");return I}),this.buildAddValidatorTx=(t,e,i,a,r,d,l,n,h,u,c=new o.default(0),A=1,D,k=(0,g.UnixNow)())=>s(this,void 0,void 0,function*(){let s=this._cleanAddressArray(e,"buildAddValidatorTx").map(t=>b.stringToAddress(t)),T=this._cleanAddressArray(i,"buildAddValidatorTx").map(t=>b.stringToAddress(t)),y=this._cleanAddressArray(a,"buildAddValidatorTx").map(t=>b.stringToAddress(t)),x=this._cleanAddressArray(h,"buildAddValidatorTx").map(t=>b.stringToAddress(t));D instanceof f.PayloadBase&&(D=D.getPayload());let p=(yield this.getMinStake()).minValidatorStake;if(n.lt(p))throw new m.StakeError("PlatformVMAPI.buildAddValidatorTx -- stake amount must be at least "+p.toString(10));if("number"!=typeof u||u>100||u<0)throw new m.DelegationFeeError("PlatformVMAPI.buildAddValidatorTx -- delegationFee must be a number between 0 and 100");let v=yield this.getAVAXAssetID(),I=(0,g.UnixNow)();if(d.lt(I)||l.lte(d))throw new m.TimeError("PlatformVMAPI.buildAddValidatorTx -- startTime must be in the future and endTime must come after startTime");let w=t.buildAddValidatorTx(this.core.getNetworkID(),b.cb58Decode(this.blockchainID),v,s,T,y,(0,g.NodeIDStringToBuffer)(r),d,l,n,c,A,x,u,new o.default(0),v,D,k);if(!(yield this.checkGooseEgg(w)))throw new m.GooseEggCheckError("Failed Goose Egg Check");return w}),this.buildCreateSubnetTx=(t,e,i,a,r,o,d=(0,g.UnixNow)())=>s(this,void 0,void 0,function*(){let s=this._cleanAddressArray(e,"buildCreateSubnetTx").map(t=>b.stringToAddress(t)),l=this._cleanAddressArray(i,"buildCreateSubnetTx").map(t=>b.stringToAddress(t)),n=this._cleanAddressArray(a,"buildCreateSubnetTx").map(t=>b.stringToAddress(t));o instanceof f.PayloadBase&&(o=o.getPayload());let h=yield this.getAVAXAssetID(),u=this.core.getNetworkID(),c=b.cb58Decode(this.blockchainID),g=this.getCreateSubnetTxFee(),A=t.buildCreateSubnetTx(u,c,s,l,n,r,g,h,o,d);if(!(yield this.checkGooseEgg(A,this.getCreationTxFee())))throw new m.GooseEggCheckError("Failed Goose Egg Check");return A}),this.buildCreateChainTx=(t,e,i,a,r,o,d,l,n,h=(0,g.UnixNow)(),u=[])=>s(this,void 0,void 0,function*(){let s=this._cleanAddressArray(e,"buildCreateChainTx").map(t=>b.stringToAddress(t)),c=this._cleanAddressArray(i,"buildCreateChainTx").map(t=>b.stringToAddress(t));n instanceof f.PayloadBase&&(n=n.getPayload());let g=yield this.getAVAXAssetID();d=d.sort();let A=this.core.getNetworkID(),D=b.cb58Decode(this.blockchainID),k=this.getCreateChainTxFee(),T=t.buildCreateChainTx(A,D,s,c,a,r,o,d,l,k,g,n,h,u);if(!(yield this.checkGooseEgg(T,this.getCreationTxFee())))throw new m.GooseEggCheckError("Failed Goose Egg Check");return T}),this.getTimestamp=()=>s(this,void 0,void 0,function*(){let t=yield this.callMethod("platform.getTimestamp");return t.data.result.timestamp}),this.getRewardUTXOs=(t,e)=>s(this,void 0,void 0,function*(){let i=yield this.callMethod("platform.getRewardUTXOs",{txID:t,encoding:e});return i.data.result}),this.blockchainID=h.PlatformChainID;let i=t.getNetworkID();if(i in h.Defaults.network&&this.blockchainID in h.Defaults.network[`${i}`]){let t=h.Defaults.network[`${i}`][this.blockchainID].alias;this.keychain=new n.KeyChain(this.core.getHRP(),t)}else this.keychain=new n.KeyChain(this.core.getHRP(),this.blockchainID)}_cleanAddressArray(t,e){let i=[],s=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID();if(t&&t.length>0)for(let e=0;e<t.length;e++)if("string"==typeof t[`${e}`]){if(void 0===this.parseAddress(t[`${e}`]))throw new m.AddressError("Error - Invalid address format");i.push(t[`${e}`])}else i.push(T.bufferToType(t[`${e}`],"bech32",this.core.getHRP(),s));return i}}e.PlatformVMAPI=y}}]);