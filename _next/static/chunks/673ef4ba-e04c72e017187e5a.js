"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[852],{8928:function(e,t,s){var i=this&&this.__awaiter||function(e,t,s,i){return new(s||(s=Promise))(function(r,o){function a(e){try{n(i.next(e))}catch(e){o(e)}}function d(e){try{n(i.throw(e))}catch(e){o(e)}}function n(e){var t;e.done?r(e.value):((t=e.value)instanceof s?t:new s(function(e){e(t)})).then(a,d)}n((i=i.apply(e,t||[])).next())})},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.AVMAPI=void 0;let o=r(s(13550)),a=s(13055),d=r(s(89734)),n=s(77300),l=s(62064),h=s(67715),c=s(47809),A=s(77673),u=s(3421),f=s(98769),g=s(89858),y=s(49009),T=s(77556),v=s(3079),x=d.default.getInstance(),I=v.Serialization.getInstance();class m extends f.JRPCAPI{constructor(e,t="/ext/bc/X",s=""){super(e,t),this.keychain=new h.KeyChain("",""),this.blockchainID="",this.blockchainAlias=void 0,this.AVAXAssetID=void 0,this.txFee=void 0,this.creationTxFee=void 0,this.mintTxFee=void 0,this.getBlockchainAlias=()=>{if(void 0===this.blockchainAlias){let e=this.core.getNetworkID();if(!(e in g.Defaults.network)||!(this.blockchainID in g.Defaults.network[`${e}`]))return;this.blockchainAlias=g.Defaults.network[`${e}`][this.blockchainID].alias}return this.blockchainAlias},this.setBlockchainAlias=e=>{this.blockchainAlias=e},this.getBlockchainID=()=>this.blockchainID,this.refreshBlockchainID=e=>{let t=this.core.getNetworkID();return void 0===e&&void 0!==g.Defaults.network[`${t}`]?(this.blockchainID=g.Defaults.network[`${t}`].X.blockchainID,!0):"string"==typeof e&&(this.blockchainID=e,!0)},this.parseAddress=e=>{let t=this.getBlockchainAlias(),s=this.getBlockchainID();return x.parseAddress(e,s,t,l.AVMConstants.ADDRESSLENGTH)},this.addressFromBuffer=e=>{let t=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID(),s=this.core.getHRP();return I.bufferToType(e,"bech32",s,t)},this.getAVAXAssetID=(e=!1)=>i(this,void 0,void 0,function*(){if(void 0===this.AVAXAssetID||e){let e=yield this.getAssetDescription(g.PrimaryAssetAlias);this.AVAXAssetID=e.assetID}return this.AVAXAssetID}),this.setAVAXAssetID=e=>{"string"==typeof e&&(e=x.cb58Decode(e)),this.AVAXAssetID=e},this.getDefaultTxFee=()=>new o.default(this.core.getNetworkID() in g.Defaults.network?g.Defaults.network[this.core.getNetworkID()].X.txFee:0),this.getTxFee=()=>(void 0===this.txFee&&(this.txFee=this.getDefaultTxFee()),this.txFee),this.setTxFee=e=>{this.txFee=e},this.getDefaultCreationTxFee=()=>new o.default(this.core.getNetworkID() in g.Defaults.network?g.Defaults.network[this.core.getNetworkID()].X.creationTxFee:0),this.getDefaultMintTxFee=()=>new o.default(this.core.getNetworkID() in g.Defaults.network?g.Defaults.network[this.core.getNetworkID()].X.mintTxFee:0),this.getMintTxFee=()=>(void 0===this.mintTxFee&&(this.mintTxFee=this.getDefaultMintTxFee()),this.mintTxFee),this.getCreationTxFee=()=>(void 0===this.creationTxFee&&(this.creationTxFee=this.getDefaultCreationTxFee()),this.creationTxFee),this.setMintTxFee=e=>{this.mintTxFee=e},this.setCreationTxFee=e=>{this.creationTxFee=e},this.keyChain=()=>this.keychain,this.newKeyChain=()=>{let e=this.getBlockchainAlias();return e?this.keychain=new h.KeyChain(this.core.getHRP(),e):this.keychain=new h.KeyChain(this.core.getHRP(),this.blockchainID),this.keychain},this.checkGooseEgg=(e,t=new o.default(0))=>i(this,void 0,void 0,function*(){let s=yield this.getAVAXAssetID(),i=t.gt(new o.default(0))?t:e.getOutputTotal(s),r=e.getBurn(s);return!!(r.lte(g.ONEAVAX.mul(new o.default(10)))||r.lte(i))}),this.getBalance=(e,t,s=!1)=>i(this,void 0,void 0,function*(){if(void 0===this.parseAddress(e))throw new T.AddressError("Error - AVMAPI.getBalance: Invalid address format");let i=yield this.callMethod("avm.getBalance",{address:e,assetID:t,includePartial:s});return i.data.result}),this.createAddress=(e,t)=>i(this,void 0,void 0,function*(){let s=yield this.callMethod("avm.createAddress",{username:e,password:t});return s.data.result.address}),this.createFixedCapAsset=(e,t,s,r,o,a)=>i(this,void 0,void 0,function*(){let i=yield this.callMethod("avm.createFixedCapAsset",{name:s,symbol:r,denomination:o,username:e,password:t,initialHolders:a});return i.data.result.assetID}),this.createVariableCapAsset=(e,t,s,r,o,a)=>i(this,void 0,void 0,function*(){let i=yield this.callMethod("avm.createVariableCapAsset",{name:s,symbol:r,denomination:o,username:e,password:t,minterSets:a});return i.data.result.assetID}),this.createNFTAsset=(e,t,s,r,o,a,d)=>i(this,void 0,void 0,function*(){let i={username:e,password:t,name:o,symbol:a,minterSet:d};if(void 0!==(s=this._cleanAddressArray(s,"createNFTAsset"))&&(i.from=s),void 0!==r){if(void 0===this.parseAddress(r))throw new T.AddressError("Error - AVMAPI.createNFTAsset: Invalid address format");i.changeAddr=r}let n=yield this.callMethod("avm.createNFTAsset",i);return n.data.result.assetID}),this.mint=(e,t,s,r,a,d)=>i(this,void 0,void 0,function*(){let i,n;i="string"!=typeof r?x.cb58Encode(r):r,n="number"==typeof s?new o.default(s):s;let l=yield this.callMethod("avm.mint",{username:e,password:t,amount:n,assetID:i,to:a,minters:d});return l.data.result.txID}),this.mintNFT=(e,t,s,r,o,a,d,n="hex")=>i(this,void 0,void 0,function*(){let i;if(void 0===this.parseAddress(d))throw new T.AddressError("Error - AVMAPI.mintNFT: Invalid address format");i="string"!=typeof a?x.cb58Encode(a):a;let l={username:e,password:t,assetID:i,payload:o,to:d,encoding:n};if(void 0!==(s=this._cleanAddressArray(s,"mintNFT"))&&(l.from=s),void 0!==r){if(void 0===this.parseAddress(r))throw new T.AddressError("Error - AVMAPI.mintNFT: Invalid address format");l.changeAddr=r}let h=yield this.callMethod("avm.mintNFT",l);return h.data.result.txID}),this.sendNFT=(e,t,s,r,o,a,d)=>i(this,void 0,void 0,function*(){let i;if(void 0===this.parseAddress(d))throw new T.AddressError("Error - AVMAPI.sendNFT: Invalid address format");i="string"!=typeof o?x.cb58Encode(o):o;let n={username:e,password:t,assetID:i,groupID:a,to:d};if(void 0!==(s=this._cleanAddressArray(s,"sendNFT"))&&(n.from=s),void 0!==r){if(void 0===this.parseAddress(r))throw new T.AddressError("Error - AVMAPI.sendNFT: Invalid address format");n.changeAddr=r}let l=yield this.callMethod("avm.sendNFT",n);return l.data.result.txID}),this.exportKey=(e,t,s)=>i(this,void 0,void 0,function*(){if(void 0===this.parseAddress(s))throw new T.AddressError("Error - AVMAPI.exportKey: Invalid address format");let i=yield this.callMethod("avm.exportKey",{username:e,password:t,address:s});return i.data.result.privateKey}),this.importKey=(e,t,s)=>i(this,void 0,void 0,function*(){let i=yield this.callMethod("avm.importKey",{username:e,password:t,privateKey:s});return i.data.result.address}),this.export=(e,t,s,r,o)=>i(this,void 0,void 0,function*(){let i=yield this.callMethod("avm.export",{username:e,password:t,to:s,amount:r,assetID:o});return i.data.result.txID}),this.import=(e,t,s,r)=>i(this,void 0,void 0,function*(){let i=yield this.callMethod("avm.import",{username:e,password:t,to:s,sourceChain:r});return i.data.result.txID}),this.listAddresses=(e,t)=>i(this,void 0,void 0,function*(){let s=yield this.callMethod("avm.listAddresses",{username:e,password:t});return s.data.result.addresses}),this.getAllBalances=e=>i(this,void 0,void 0,function*(){if(void 0===this.parseAddress(e))throw new T.AddressError("Error - AVMAPI.getAllBalances: Invalid address format");let t=yield this.callMethod("avm.getAllBalances",{address:e});return t.data.result.balances}),this.getAssetDescription=e=>i(this,void 0,void 0,function*(){let t;t="string"!=typeof e?x.cb58Encode(e):e;let s=yield this.callMethod("avm.getAssetDescription",{assetID:t});return{name:s.data.result.name,symbol:s.data.result.symbol,assetID:x.cb58Decode(s.data.result.assetID),denomination:parseInt(s.data.result.denomination,10)}}),this.getTx=(e,t="hex")=>i(this,void 0,void 0,function*(){let s=yield this.callMethod("avm.getTx",{txID:e,encoding:t});return s.data.result.tx}),this.getTxStatus=e=>i(this,void 0,void 0,function*(){let t=yield this.callMethod("avm.getTxStatus",{txID:e});return t.data.result.status}),this.getUTXOs=(e,t,s=0,r,o,d="hex")=>i(this,void 0,void 0,function*(){"string"==typeof e&&(e=[e]);let i={addresses:e,limit:s,encoding:d};void 0!==r&&r&&(i.startIndex=r),void 0!==t&&(i.sourceChain=t);let l=yield this.callMethod("avm.getUTXOs",i),h=new n.UTXOSet,c=l.data.result.utxos;if(o&&"object"==typeof o){if(this.db.has(o.getName())){let e=this.db.get(o.getName());if(Array.isArray(e)){h.addArray(c);let t=new n.UTXOSet;t.addArray(e),t.mergeByRule(h,o.getMergeRule()),c=t.getAllUTXOStrings()}}this.db.set(o.getName(),c,o.getOverwrite())}if(c.length>0&&"0x"===c[0].substring(0,2)){let e=[];c.forEach(t=>{e.push(x.cb58Encode(new a.Buffer(t.slice(2),"hex")))}),h.addArray(e,!1)}else h.addArray(c,!1);return l.data.result.utxos=h,l.data.result}),this.buildBaseTx=(e,t,s,r,a,d,n,l=(0,u.UnixNow)(),h=new o.default(0),c=1)=>i(this,void 0,void 0,function*(){let i="buildBaseTx",o=this._cleanAddressArray(r,i).map(e=>x.stringToAddress(e)),u=this._cleanAddressArray(a,i).map(e=>x.stringToAddress(e)),f=this._cleanAddressArray(d,i).map(e=>x.stringToAddress(e));"string"==typeof s&&(s=x.cb58Decode(s)),n instanceof A.PayloadBase&&(n=n.getPayload());let g=this.core.getNetworkID(),y=x.cb58Decode(this.blockchainID),v=this.getTxFee(),I=yield this.getAVAXAssetID(),m=e.buildBaseTx(g,y,t,s,o,u,f,v,I,n,l,h,c);if(!(yield this.checkGooseEgg(m)))throw new T.GooseEggCheckError("Error - AVMAPI.buildBaseTx:Failed Goose Egg Check");return m}),this.buildNFTTransferTx=(e,t,s,r,a,d,n=(0,u.UnixNow)(),l=new o.default(0),h=1)=>i(this,void 0,void 0,function*(){let i="buildNFTTransferTx",o=this._cleanAddressArray(t,i).map(e=>x.stringToAddress(e)),c=this._cleanAddressArray(s,i).map(e=>x.stringToAddress(e)),u=this._cleanAddressArray(r,i).map(e=>x.stringToAddress(e));d instanceof A.PayloadBase&&(d=d.getPayload());let f=yield this.getAVAXAssetID(),g=[];"string"==typeof a?g=[a]:Array.isArray(a)&&(g=a);let y=e.buildNFTTransferTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),o,c,u,g,this.getTxFee(),f,d,n,l,h);if(!(yield this.checkGooseEgg(y)))throw new T.GooseEggCheckError("Error - AVMAPI.buildNFTTransferTx:Failed Goose Egg Check");return y}),this.buildImportTx=(e,t,s,r,d,n,l,h=(0,u.UnixNow)(),c=new o.default(0),f=1)=>i(this,void 0,void 0,function*(){let i;let o="buildImportTx",u=this._cleanAddressArray(r,o).map(e=>x.stringToAddress(e)),g=this._cleanAddressArray(d,o).map(e=>x.stringToAddress(e)),y=this._cleanAddressArray(n,o).map(e=>x.stringToAddress(e));if(void 0===s)throw new T.ChainIdError("Error - AVMAPI.buildImportTx: Source ChainID is undefined.");if("string"==typeof s)i=s,s=x.cb58Decode(s);else if(!(s instanceof a.Buffer))throw new T.ChainIdError("Error - AVMAPI.buildImportTx: Invalid destinationChain type: "+typeof s);let v=(yield this.getUTXOs(t,i,0,void 0)).utxos,I=yield this.getAVAXAssetID(),m=v.getAllUTXOs();if(0===m.length)throw new T.NoAtomicUTXOsError("Error - AVMAPI.buildImportTx: No atomic UTXOs to import from "+i+" using addresses: "+t.join(", "));l instanceof A.PayloadBase&&(l=l.getPayload());let w=e.buildImportTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),u,g,y,m,s,this.getTxFee(),I,l,h,c,f);if(!(yield this.checkGooseEgg(w)))throw new T.GooseEggCheckError("Error - AVMAPI.buildImportTx:Failed Goose Egg Check");return w}),this.buildExportTx=(e,t,s,r,d,n,l,h=(0,u.UnixNow)(),c=new o.default(0),f=1,g)=>i(this,void 0,void 0,function*(){let i={};if(r.map(e=>{i[e.split("-")[0]]=!0}),1!==Object.keys(i).length)throw new T.AddressError("Error - AVMAPI.buildExportTx: To addresses must have the same chainID prefix.");if(void 0===s)throw new T.ChainIdError("Error - AVMAPI.buildExportTx: Destination ChainID is undefined.");if("string"==typeof s)s=x.cb58Decode(s);else if(!(s instanceof a.Buffer))throw new T.ChainIdError("Error - AVMAPI.buildExportTx: Invalid destinationChain type: "+typeof s);if(32!==s.length)throw new T.ChainIdError("Error - AVMAPI.buildExportTx: Destination ChainID must be 32 bytes in length.");let o=[];r.map(e=>{o.push(x.stringToAddress(e))});let u="buildExportTx",y=this._cleanAddressArray(d,u).map(e=>x.stringToAddress(e)),v=this._cleanAddressArray(n,u).map(e=>x.stringToAddress(e));l instanceof A.PayloadBase&&(l=l.getPayload());let I=yield this.getAVAXAssetID();void 0===g&&(g=x.cb58Encode(I));let m=this.core.getNetworkID(),w=x.cb58Decode(this.blockchainID),E=x.cb58Decode(g),p=this.getTxFee(),D=e.buildExportTx(m,w,t,E,o,y,v,s,p,I,l,h,c,f);if(!(yield this.checkGooseEgg(D)))throw new T.GooseEggCheckError("Error - AVMAPI.buildExportTx:Failed Goose Egg Check");return D}),this.buildCreateAssetTx=(e,t,s,r,o,a,d,n,h,c=(0,u.UnixNow)())=>i(this,void 0,void 0,function*(){let i="buildCreateAssetTx",u=this._cleanAddressArray(t,i).map(e=>x.stringToAddress(e)),f=this._cleanAddressArray(s,i).map(e=>x.stringToAddress(e));if(h instanceof A.PayloadBase&&(h=h.getPayload()),a.length>l.AVMConstants.SYMBOLMAXLEN)throw new T.SymbolError("Error - AVMAPI.buildCreateAssetTx: Symbols may not exceed length of "+l.AVMConstants.SYMBOLMAXLEN);if(o.length>l.AVMConstants.ASSETNAMELEN)throw new T.NameError("Error - AVMAPI.buildCreateAssetTx: Names may not exceed length of "+l.AVMConstants.ASSETNAMELEN);let g=this.core.getNetworkID(),y=x.cb58Decode(this.blockchainID),v=yield this.getAVAXAssetID(),I=this.getDefaultCreationTxFee(),m=e.buildCreateAssetTx(g,y,u,f,r,o,a,d,n,I,v,h,c);if(!(yield this.checkGooseEgg(m,I)))throw new T.GooseEggCheckError("Error - AVMAPI.buildCreateAssetTx:Failed Goose Egg Check");return m}),this.buildSECPMintTx=(e,t,s,r,o,a,d,n=(0,u.UnixNow)())=>i(this,void 0,void 0,function*(){let i="buildSECPMintTx",l=this._cleanAddressArray(r,i).map(e=>x.stringToAddress(e)),h=this._cleanAddressArray(o,i).map(e=>x.stringToAddress(e));d instanceof A.PayloadBase&&(d=d.getPayload());let c=this.core.getNetworkID(),u=x.cb58Decode(this.blockchainID),f=yield this.getAVAXAssetID(),g=this.getMintTxFee(),y=e.buildSECPMintTx(c,u,t,s,l,h,a,g,f,d,n);if(!(yield this.checkGooseEgg(y)))throw new T.GooseEggCheckError("Error - AVMAPI.buildSECPMintTx:Failed Goose Egg Check");return y}),this.buildCreateNFTAssetTx=(e,t,s,r,a,d,n,h=(0,u.UnixNow)(),c=new o.default(0))=>i(this,void 0,void 0,function*(){let i="buildCreateNFTAssetTx",o=this._cleanAddressArray(t,i).map(e=>x.stringToAddress(e)),u=this._cleanAddressArray(s,i).map(e=>x.stringToAddress(e));if(n instanceof A.PayloadBase&&(n=n.getPayload()),a.length>l.AVMConstants.ASSETNAMELEN)throw new T.NameError("Error - AVMAPI.buildCreateNFTAssetTx: Names may not exceed length of "+l.AVMConstants.ASSETNAMELEN);if(d.length>l.AVMConstants.SYMBOLMAXLEN)throw new T.SymbolError("Error - AVMAPI.buildCreateNFTAssetTx: Symbols may not exceed length of "+l.AVMConstants.SYMBOLMAXLEN);let f=this.core.getNetworkID(),g=x.cb58Decode(this.blockchainID),y=this.getCreationTxFee(),v=yield this.getAVAXAssetID(),I=e.buildCreateNFTAssetTx(f,g,o,u,r,a,d,y,v,n,h,c);if(!(yield this.checkGooseEgg(I,y)))throw new T.GooseEggCheckError("Error - AVMAPI.buildCreateNFTAssetTx:Failed Goose Egg Check");return I}),this.buildCreateNFTMintTx=(e,t,s,r,o,a=0,d,n,l=(0,u.UnixNow)())=>i(this,void 0,void 0,function*(){let i="buildCreateNFTMintTx",h=this._cleanAddressArray(s,i).map(e=>x.stringToAddress(e)),c=this._cleanAddressArray(r,i).map(e=>x.stringToAddress(e));n instanceof A.PayloadBase&&(n=n.getPayload()),d instanceof A.PayloadBase&&(d=d.getPayload()),"string"==typeof o&&(o=[o]);let u=yield this.getAVAXAssetID();t instanceof y.OutputOwners&&(t=[t]);let f=this.core.getNetworkID(),g=x.cb58Decode(this.blockchainID),v=this.getTxFee(),I=e.buildCreateNFTMintTx(f,g,t,h,c,o,a,d,v,u,n,l);if(!(yield this.checkGooseEgg(I)))throw new T.GooseEggCheckError("Error - AVMAPI.buildCreateNFTMintTx:Failed Goose Egg Check");return I}),this.signTx=e=>e.sign(this.keychain),this.issueTx=e=>i(this,void 0,void 0,function*(){let t="";if("string"==typeof e)t=e;else if(e instanceof a.Buffer){let s=new c.Tx;s.fromBuffer(e),t=s.toStringHex()}else if(e instanceof c.Tx)t=e.toStringHex();else throw new T.TransactionError("Error - AVMAPI.issueTx: provided tx is not expected type of string, Buffer, or Tx");let s={tx:t.toString(),encoding:"hex"},i=yield this.callMethod("avm.issueTx",s);return i.data.result.txID}),this.getAddressTxs=(e,t,s,r)=>i(this,void 0,void 0,function*(){let i;i="string"!=typeof r?x.cb58Encode(r):r;let o=yield this.callMethod("avm.getAddressTxs",{address:e,cursor:t,pageSize:"number"!=typeof s?0:s,assetID:i});return o.data.result}),this.send=(e,t,s,r,a,d,n,l)=>i(this,void 0,void 0,function*(){let i,h;if(void 0===this.parseAddress(a))throw new T.AddressError("Error - AVMAPI.send: Invalid address format");i="string"!=typeof s?x.cb58Encode(s):s,h="number"==typeof r?new o.default(r):r;let c={username:e,password:t,assetID:i,amount:h.toString(10),to:a};if(void 0!==(d=this._cleanAddressArray(d,"send"))&&(c.from=d),void 0!==n){if(void 0===this.parseAddress(n))throw new T.AddressError("Error - AVMAPI.send: Invalid address format");c.changeAddr=n}void 0!==l&&("string"!=typeof l?c.memo=x.cb58Encode(l):c.memo=l);let A=yield this.callMethod("avm.send",c);return A.data.result}),this.sendMultiple=(e,t,s,r,a,d)=>i(this,void 0,void 0,function*(){let i,n;let l=[];s.forEach(e=>{if(void 0===this.parseAddress(e.to))throw new T.AddressError("Error - AVMAPI.sendMultiple: Invalid address format");i="string"!=typeof e.assetID?x.cb58Encode(e.assetID):e.assetID,n="number"==typeof e.amount?new o.default(e.amount):e.amount,l.push({to:e.to,assetID:i,amount:n.toString(10)})});let h={username:e,password:t,outputs:l};if(void 0!==(r=this._cleanAddressArray(r,"send"))&&(h.from=r),void 0!==a){if(void 0===this.parseAddress(a))throw new T.AddressError("Error - AVMAPI.send: Invalid address format");h.changeAddr=a}void 0!==d&&("string"!=typeof d?h.memo=x.cb58Encode(d):h.memo=d);let c=yield this.callMethod("avm.sendMultiple",h);return c.data.result}),this.buildGenesis=e=>i(this,void 0,void 0,function*(){let t=yield this.callMethod("avm.buildGenesis",{genesisData:e});return t.data.result.bytes}),this.blockchainID=s;let r=e.getNetworkID();if(r in g.Defaults.network&&s in g.Defaults.network[`${r}`]){let e=g.Defaults.network[`${r}`][`${s}`].alias;this.keychain=new h.KeyChain(this.core.getHRP(),e)}else this.keychain=new h.KeyChain(this.core.getHRP(),s)}_cleanAddressArray(e,t){let s=[],i=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID();if(e&&e.length>0)for(let t=0;t<e.length;t++)if("string"==typeof e[`${t}`]){if(void 0===this.parseAddress(e[`${t}`]))throw new T.AddressError("Error - AVMAPI.${caller}: Invalid address format");s.push(e[`${t}`])}else s.push(I.bufferToType(e[`${t}`],"bech32",this.core.getHRP(),i));return s}}t.AVMAPI=m}}]);